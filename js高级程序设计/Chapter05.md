## 第五章：引用类型

1. 使用对象
2. 创建并操作数组
3. 理解基本的JavaScript类型
4. 使用基本类型和基本包装类型

对象是某个特定引用类型的**实例**。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数只是处于创建新对象的目的而定义的。

### 5.1 Object类型

Object类型是ECMAScript中使用最多的一个类型。

有两种创建Object实例的方式：

* 使用new操作符后跟Object构造函数。
* 使用对象字面量表示法。

````js
// 第一种
var person = new Object();
person.name = "Nicholas";
// 第二种
var person = {
	name = "Nicholas",
	age = 20
};
````

访问对象属性时有两种方法：

* 点表示法：person.name
* 方括号表示法：person["name"]。可以通过**变量**访问属性。

### 5.2 Array类型

ECMAScript数组与其他数组有以下不同：

* 数组的每一项可以保存任何类型的数据；
* 数组的大小可以动态调整（随着数据的添加自动添加）；

创建数组的基本方式有两种：

1. 使用Array构造函数。
2. 使用数组字面量表示法。

````js
// 第一种方法, 也可以省略`new`操作符。
var colors1 = new Array();
var colors2 = new Array(3);
var colors3 =  new Array("red");
var colors4 = new Array("red", "blue", "yellow");
// 第二种方法
var colors = ["red", "blue", "green"];
````

数组有一个`length`属性——它不只是只读的。（通过设置length可以从数组末尾移除项或向数组添加新项。如：`arr.length = new_item`

#### 检测数组

`Array.isArray(value)`：最终确定某个值是否是数组。

所有的函数参数都是**按值传递**的。即把值赋值给命名参数`arguments`的一个元素。

当参数为对象类型时，对象的引用通过按值传递后也能被处理函数引用到。

#### 转换方法

* toString()：返回数组元素以逗号分隔的字符串。
* valueOf()：返回结果与toString()相同。
* toLocaleString()：数组元素以逗号分隔的字符串，调用toLocaleString方法。
* join(separator)方法：自定义分隔符separator

若数组中某一项是undefined，则返回结果以空字符串表示。

#### 栈方法

数组有`push()`和`pop()`两种方法以实现类似栈的行为（LIFO）。

* `push()`：接收**任意数量**的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。
* `pop()`：从数组末尾移除最后一项，减少数组的length值，然后返回移除项。

#### 队列方法

数组有`shift()`和`unshift()`两种方法以实现类似队列的行为(FIFO)。

* `shift()`：移除数组中的第一项并返回该项。
* `unshift()`：在数组前端添加**任意个**项并返回新数组的长度。

#### 重排序方法

* `reverse()`：反转数组项的顺序。
* `sort()`：默认情况下，按**升序**排列数组项。`sort()`方法会调用每个数组项的`toString()`转型方法，然后**比较得到的字符串**进行排序。这在直接对数值型数据排序是会出错。

`sort()`接收一个比较函数作为参数，以便指定哪个值位于前面。若第一个参数应该位于第二个之前则返回一个负数，相等则返回0，否则返回正数。(升序时，返回正数才需要对换顺序)。

````js
function compare(value1, value2) {
	if(value1 < value2) {
		return -1;
	}else if(value1 > value2) {
		return 1;
	}else {
		return 0;
	}
}
// compare()函数可以简化为：
function compare2(value1, value2) {
	return value1- value2;
}
var values = [0,1,5,10,15];
values.sort(compare);
alert(values); // 0,1,5,10,15
````

#### 操作方法

* `concat()`方法：基于当前数组中所有项创建一个**新数组**。传入参数时，添加参数数组至结果数组末尾。
* `slice()`方法：接受1~2个参数，返回当前数组项的起始和结束位置之间项的新数组。（从0开始）
* `splice()`方法：多种用途，会改变当前数组。
	* 删除：指定2个参数，要删除的第一项的位置和要删除的项数。
	* 插入：提供3个参数：起始位置、0（要删除的项数）和要插入的项。
	* 替换：向指定位置插入任意数量的项，同时删除任意数量的项。指定3个参数：
	起始位置、要删除的项数和要插入的任意数量的项。
	
> `splice()`始终返回一个从原数组中删除的项，若没有删除任何项则返回一个空数组。

#### 位置方法

`indexOf()`和`lastIndexOf()`，都接受两个参数：要查找的项和表示查找起点的索引（可选）。

* `indexOf()`：从数组开头开始从前向后查找。
* `lastIndexOf()`：从数组末尾开始从后向前查找

两个方法的查找都使用**全等操作符**，都返回要查找的项在数组中的位置，没找到的情况下返回-1。

#### 迭代方法

为数组定义了5个迭代方法，每个方法都接收两个参数：要在每一项上运行的函数运行该桉树的作用域对象（可选）—— 影响`this`的值。传入这些方法中的函数接收3个参数：数组项的值、该项在数组中的位置和数组对象本身。

* every()：对数组中的每一项运行给定函数，若函数对每一项都返回true，则返回true。
* filter()：对数组中的每一项运行给定函数，返回该函数会**返回true的项组成的数组**。
* forEach()：对数组中的每一项运行给定函数。这个函数没有返回值。
* map()：对数组中的每一项运行给定函数，**返回每次函数调用结果组成的数组**。
* some()：对数组中的每一项运行给定函数，如果函数对任一项返回true，则返回true。

#### 归并方法

两个归并数组的方法，都会迭代数组的所有项，然后构建一个最终的返回值：

* `reduce()`：从第一项开始，逐个遍历到最后。
* `reduceRight()`：从最后一项开始，向前遍历到第一项。

这两个方法都接收两个参数：在每一项上调用的函数和作为归并基础的初始值(可选)。

被调用的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上。

````js
var values = [1,2,3,4,5];
var sum = values.reduce(function(prev, cur, index, array) {
	return prev + cur;
});
alert(sum); // 15
````

### 5.3 Date类型

Date类型使用UTC(Coordinated Universal Time, 国际协调时间)1970年1月1日午夜开始经过的毫秒数来保存日期。

创建一个日期对象很简单：

````js
var now = new Date();
````

有两个关于日期的方法：

* Date.parse()：接收一个表示日期的字符串参数，然后根据这个字符串返回相应日期的毫秒数。接收以下多种格式(如果传入的参数字符串不能表示日期，那么它会返回NaN)：
	* "月/日/年"，如6/13/2004
	* "英文月名，日，年",如January 12,2004
	* "英文星期几 英文月名 日 年 时:分：秒 时区",如 Tue May 25 2004 00:00:00 GMT-0700
	* ISO 8601扩展格式 YYYY-MM-DDTHH:mm:ss.sssZ,如2004-05-25T00:00:00
* Date.UTC()：同样返回表示日期的毫秒数，参数不同。参数分别是年份、基于0的月份（一月是0）、月中的哪一天、小时数（0到23）、分钟、秒以及毫秒数。前两个参数年和月是必须的，省略其他参数则默认为0。

````js
// GMT时间2005年5月5日17:55:55
var data1 = new Date(Date.UTC(2005, 4, 5, 17, 55,55)); 
// 本地时间2005年5月5日17:55:55
var data2 = new Date(2005, 4, 4, 17, 55, 55);
````

#### 继承的方法

Date类型重写了`toLocaleString()`，`toString()`和`valueOf()`方法：

* `toLocaleString()`：按照与浏览器设置的地区相适应的格式返回日期和时间。
* `toString()`：返回带有时区信息的日期和时间。

#### 日期格式化方法

Date类型还有一些专门用于将日期格式化为字符串的方法，如`toDateString()`、`toTimeString()`、`toLocaleDateString()`、`toLocaleTimeString()`、`toUTCString()`。

####日期/时间组件方法

`getTime()`、`getDate()`、`setHours()`等，使用时具体选用就好。


### 5.4 RegExp类型

ECMAScript通过RegExp类型来支持正则表达式。通过一下语法就能创建一个正则表达式。

````js
var expression = / pattern / flags;
````

其中pattern可以是任何简单或复杂的正则表达式。每个正则表达式都可带有一或多个标志(flags)，用以标明正则表达式的行为。正则表达式的匹配模式支持下列3个标志：

* g：全局（global）模式。即模式应用与所有字符串，而非在发现第一个匹配项时立即停止。
* i：不区分大小写（case-insensitive）模式。即确定匹配项时忽略模式与字符串的大小写。
* m：多行（multiline）模式。即到达一行文本末尾时还会继续查找下一行是否有与之匹配的项。

正则表达式的匹配模式规则比较复杂，又需要系统学习，这里不继续深入。

#### RegExp实例属性

RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。

- [x] global：布尔值，表示是否设置了g标志。
- [x] ignoreCase：布尔值，表示是否设置了j标志。
- [x] lastIndex：整数，表示开始搜素下一个匹配项的字符位置。
- [x] multiline：布尔值，表示是否设置了m标志。
- [x] source：正则表达死的字符串表示，按照字面量形式而非构造函数中的字符串模式返回。


#### RegExp实例方法

* exec()：接收一个参数，即要应用模式的字符串，返回包含第一个匹配项信息的数组，在没有匹配情况下返回null。
 
 这部分另作讨论。
 
 
### 5.5 Function类型

函数实际上是对象，每个函数都是Function类型的实例。函数名实际上是一个指向函数对象的指针，不会与某个函数绑定，即"函数是对象，函数名是指针"。

函数声明有3种方法：

````js
// 1 函数声明语法
function sum(num1, num2) {
	return num1 + num2;
}
// 2 匿名函数声明（通过sum变量即可引用函数）
var sum = function(num1, num2) {
	return num1 + num2;
}
// 3 Function构造函数声明(不推荐使用)
var sum = new Fcuntion("num1", "num2", "return num1 + num2");
````

#### 没有重载

将函数名想象为指针有助于理解为何ECMAScript中没有函数重载。

第二个创建的函数实际上覆盖了第一个变量对函数的引用。

#### 函数声明和函数表达式

解析器率先读取函数声明，并在其执行任何代码之前可用。（函数声明提升 function declaration hoisting）

函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。

````js
// 下面代码可以正常运行，**函数声明**在alert之前就已经提升至函数顶部了。
alert(sum);
function sum(num1, num2) {
	return num1 + num2;
}

// 这段运行期间会发生错误，原因在于函数位于一个初始化语句中，而不是一个声明中。在执行到函数所在的语句之前，变量sum不会保存对函数的引用。（类似先使用变量再声明，这是不对的。）
alert(sum);
var sum = function() {
	return num1 + num2;
}
````

#### 作为值的函数

函数可以作为传递参数传递给另一个函数，也可以作为另一个函数的返回结果。

#### 函数的内部属性

函数内部有两个特殊属性：`arguments`和`this`。

`arguments`是一个类数组，主要用途是保存参数。这个对象还有一个名叫`callee`的属性。这个属性是一个指针，指向拥有这个`arguments`对象的函数。

`this`引用的是**函数据以执行的环境对象。**
 
 `caller`保存着保存着调用当前函数的函数的引用。全局作用域中调用当前函数则它的值为null。
 
#### 函数属性和方法
 
 每个函数都包含两个属性：length和prototype。
 
 `length`：表示函数希望接受的命名参数的个数。
 
 `prototype`：引用类型中，`prototype`是保存所有实例方法的真正所在。
 
 每个函数都包含都包含两个非继承而来的方法：`apply()`和`call()`。这两个方法的用途都是在特定的作用域中调用函数，等于设置函数体内的this对象的值。其作用主要在于**扩充函数赖以运行的作用域**，且对象不需要与方法有任何耦合关系。
 
 `apply()`接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组（可以是Array实例，也可以是`arguments`对象）。
 
 `call()`方法的作用相同，区别在于`call()`函数第一个参数是this，其余参数都直接传递给函数。
 
 ECMAScript还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this值会被绑定传给bind()函数的值。
 
### 5.6 基本包装类型
 
 为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：Boolean、Number和String。
 
 基于后台这种解决方案，字符串可以调用方法，如：
 
 ````js
 var s1 = "some text";
 var s2 = s1.substring(2);
 ````
 
 以上代码实际上经过了以下处理，是的字符串可以像对象一样操作：
 
 1. 创建String类型的一个实例；
 2. 在实例上调用指定的方法；
 3. 销毁这个实例。
 
 #### 字符串的方法
 
 * 字符方法
 	* charAt()：接收基于0的字符位置。以单字符字符串的形式返回给定位置的那个字符。
 	* charCodeAt()：接收基于0的字符位置。返回对应位置字符的字符编码。
 	* 通过方括号+数字索引来访问字符串中特定字符。// "hello"[1]
 * 字符串操作方法（不会修改字符串本身） 
 	* concat()：将一个或多个字符串拼接起来，可以接受任意多个参数。
 	* slice()：两个参数，第一个参数指定子字符串的开始位置，第二个参数表示子字符串最后一个字符后面的位置。
 	* substr()：两个参数，第一个参数指定子字符串的开始位置，第二个参数指定返回字符的个数。
 	* substring()：两个参数，第一个参数指定子字符串的开始位置，第二个参数表示子字符串最后一个字符后面的位置。
 * 字符串位置方法 
 	* indexOf()：从开头向后在字符串中搜索给定的子字符串，返回字符串的位置。（没有找到则返回-1）
 	* lastIndexOf()：从后向前开始向后在字符串中搜索给定的子字符串，返回字符串的位置。（没有找到则返回-1）
 * trim()方法：创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。
 * 字符串大小写转换方法
 	* toLowerCase()：转为小写。
 	* toLocaleLowerCase()：针对特定地区的实现。
 	* toUpperCase()：转为大写。
 	* toLocaleUpperCase() ：针对特定地区的实现。
 * 字符串的模式匹配方法
	* match()：匹配模式。接收一个参数，要么是正则表达死，要么是RegExp对象。
	* search()：搜索模式。参数同match。返回字符串中第一个匹配项的索引；若没有找到则返回-1.
	* replace()：两个参数，第一个是RegExp对象或一个字符串，第二个可以是一个字符串或一个函数。是字符串时，只会替换第一个匹配到字符串；提供一个指定全局匹配的正则表达式，如`/at/g`，则能够全局替换。第二个参数是字符串时，还有一些特殊字符串序列可以使用，如`$$`,`$n`,`$&`,`$'`,`$nn`...
* localeCompare()方法：比较两个字符串，并返回下列值中的一个：
	* 若字符串在字母表中应该排在字符串参数前，则返回一个负数；
	* 若字符串等于字符串参数，则返回0；
	* 若字符串在字母表中应该排在字符串参数之后，则返回一个正数。
* fromCharCode()方法：String构造函数的一个静态方法。接收一或多个字符编码，然后将它们转换成一个字符串。`String.fromCharCode(104,101,108,108,111) // "hello"` 
* HTML方法：使用js动态格式化HTML,不推荐使用。

### 5.7 单体内置对象

内置对象的定义：由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。（开发人员不必显式地实例化内置对象，因为它们已经实例化了）。

#### Global对象

所有在全局作用域中定义的属性和函数，都是Global对象的属性。

* URI编码方法：`encodeURI()`和`encodeURIComponent()`方法对URI进行编码，以便发送给浏览器。URI中不接受某些特殊字符，因此通过URI编码方法，用特殊的UTF-8编码替换无效字符从而让浏览器能够接受。
	* `encodeURI()`用于整个URI，不会对本身属于URI的特殊字符进行编码，如冒号，问号，井号。对应`decodeURI()`。
	* `encodeURIComponent()`主要用于对URI中的某一段进行编码。对它发现的任何非标准字符进行编码。对应`decodeURIComponent()`。

* `eval()`方法：只接受一个参数，即要执行的ECMAScript字符串，并将参数作为实际ECMAScript语句来解析。使用时需要尤其注意，否则可能出现代码注入问题。
* window对象。Web浏览器将Global全局对象作为window对象的一部分加以实现。因此在全局作用域中声明的所有变量和函数，都成为了window对象的属性。

#### Math对象

为保存数学公式和信息提供了一个公共位置，即Math对象。Math对象提供了辅助完成这些计算的属性和方法。

* Math对象的属性。常用的如Math.E（自然对数的底数，即常量e），Math.PI（π的值），Math.SQRT2（2的平方根）。
* `min()`和`max()`方法。取最小值和最大值方法。
````js
// 计算数组中的最大值或者最小值
var arr = [2,4,5,6,8,13];
var min = Math.min.apply(Math, arr); //将ath对象作为第一个参数，从而设置this的值。
````
* 舍入方法。
	* Math.ceil()：向上舍入为最接近的整数。
	* Math.floor()：向下舍入为最接近的整数。
	* Math.round()：按标准四舍五入进行舍入。
* random()方法。Math.random()方法返回大于等于0小于1的一个随机数。
````js
// 生成一个介于2到10之间的值。因此可能值的总数是9，第一个可能值是2。
var num = Math.floor(Math.random()*9 + 2);
````
* 其他方法，如：Math.abs(num)、Math.pow(num,power)、Math.sqrt(num)


